import * as angular from 'angular';
declare module 'smarteditcontainer' {
// ******************************************************* 
// This file is automatically generated 
// Do not modify this file -- YOUR CHANGES WILL BE ERASED! 
// ******************************************************* 


export class YAnnouncementBoardComponent implements ISeComponent {
    
    constructor(announcementService: AnnouncementService);
    getAnnouncements: () => IAnnouncement[];
}




export class YAnnouncementComponent implements ISeComponent {
    
    announcement: IAnnouncement;
    constructor(announcementService: AnnouncementService);
    hasTemplate: () => boolean;
    hasTemplateUrl: () => boolean;
    hasMessage: () => boolean;
    hasMessageTitle: () => boolean;
    hasController: () => boolean;
    isCloseable: () => boolean;
    closeAnnouncement: () => void;
}



/// <reference types="angular-mocks" />



export class ConfigurationModalController {
    
    
    
    
    
    init: () => void;
    
    
    
    
    constructor(confirmationModalService: any, $scope: ConfigurationModalControllerScope, $timeout: angular.ITimeoutService, yjQuery: JQueryStatic, configurationService: ConfigurationService, $q: angular.IQService, modalManager: any);
}

export * from './topToolbars';
export * from './experienceSelector/ExperienceSelectorComponent';
export * from './userAccount/UserAccountComponent';
export * from './sitesLink/SitesLinkComponent';
export * from './announcements/YAnnouncementBoardComponent';
export * from './announcements/YAnnouncementComponent';

export class InvalidRouteComponent {
}




export class SmarteditcontainerComponent {
    
    upgrade: UpgradeModule;
    
    constructor(translateService: TranslateService, injector: Injector, upgrade: UpgradeModule, elementRef: ElementRef);
    ngOnInit(): void;
    ngAfterViewInit(): void;
    
    
    
    
}






/**
 * @description
 * The shortcut link configuration.
 */
export interface SeShortcutLinkConfig extends SeRouteShortcutConfig {
    active?: boolean;
}
export class ShortcutLinkComponent {
    
    
    
    
    
    containerEntry: ViewContainerRef;
    defaultTemplate: TemplateRef<any>;
    constructor(router: Router, location: Location, resolver: ComponentFactoryResolver, experienceService: IExperienceService, priorityService: PriorityService);
    ngAfterViewInit(): void;
    onClick(shortcutLink: SeShortcutLinkConfig): void;
    /**
     * Creates embedded template if the shortcut link contains titleI18nKey property otherwise
     * if the shortcut link contains shortcutComponent instance it creates a new component.
     */
    
    /**
     * Retrieves the route shortcut configs using the SeRouteService. It then generates full path replacing
     * all placeholders with values from current experience. It also verifies whether the path is active or not.
     */
    
    /**
     * Orders all shortcut links by priority. If the priority is not provided it uses the DEFAULT_PRIORITY value.
     */
    
}




export class SitesLinkComponent {
    
    
    
    cssClass: string;
    iconCssClass: string;
    shortcutLink: any;
    constructor(location: Location, iframeManagerService: IframeManagerService, LANDING_PAGE_PATH: string);
    goToSites(): void;
}



export * from './toolbarItemContext/ToolbarItemContextComponent';






export class UserAccountComponent implements ISeComponent {
    
    
    
    
    
    username: string;
    
    constructor(authenticationService: any, iframeManagerService: IframeManagerService, crossFrameEventService: CrossFrameEventService, sessionService: ISessionService, EVENTS: any);
    $onInit(): void;
    signOut(): void;
    $onDestroy(): void;
    getUsername(): void;
}


export class CustomHandlingStrategy implements UrlHandlingStrategy {
    shouldProcessUrl(url: UrlTree): boolean;
    extract(url: UrlTree): UrlTree;
    merge(newUrlPart: UrlTree, rawUrl: UrlTree): UrlTree;
}

export function deprecatedSince1905(): void;
export const deprecate: () => void;





export * from "../smarteditloader";


declare global {
}
export class Smarteditcontainer {
}



/**
 * @ngdoc overview
 * @name authenticationModule
 *
 * @description
 * # The authenticationModule
 *
 * The authentication module provides a service to authenticate and logout from SmartEdit.
 * It also allows the management of entry points used to authenticate the different resources in the application.
 *
 */

export class AuthenticationModule {
}
export interface ICredentialsMapRecord extends Payload {
    client_id: string;
    client_secret?: string;
}
export interface ICredentialsMap {
    [entryPoint: string]: ICredentialsMapRecord;
}
export interface IAuthMap {
    [entryPoint: string]: string;
}



/**
 * @ngdoc service
 * @name AlertServiceModule.service:AlertFactory
 */
/// <reference types="angular-mocks" />




export class Alert {
    
    
    
    
    
    
    promise: Promise<any>;
    
    
    
    
    constructor(_alertConf: IAlertConfig, promiseUtils: PromiseUtils, windowUtils: WindowUtils, $log: angular.ILogService, lodash: lo.LoDashStatic, sanitize: any, alertCollectionServiceFacade: AlertCollectionServiceFacade, SE_ALERT_DEFAULTS: TypedMap<string>);
    readonly alertConf: IAlertConfig;
    /**
     * Displays the alert to the user.
     */
    show(): void;
    /**
     * Hides the alert if it is currently being displayed to the user.
     */
    hide(timedOut: boolean): void;
    isDisplayed(): boolean;
    /**
     * Validates the alertConfig.
     */
    
    /**
     * Sanitizes the template and message.
     */
    
    /**
     * @deprecated since 1905
     */
    
}





/**
 * @ngdoc service
 * @name AlertServiceModule.service:AlertCollectionComponentFacade
 * @description
 * The alertCollectionComponentFacade is the interface of alertCollection exposed to the component/view layer of the application
 */
export class AlertCollectionComponentFacade {
    alertCollection: AlertCollection;
    constructor(alertCollection: AlertCollection);
    /**
     * @ngdoc method
     * @name AlertServiceModule.service:AlertCollectionComponentFacade#getAlerts
     * @methodOf AlertServiceModule.service:AlertCollectionComponentFacade
     * @returns {Alert[]} a list of all alerts.
     */
    getAlerts(): Alert[];
}


/**
 * @ngdoc service
 * @name AlertServiceModule.service:AlertCollectionLegacySupport
 * @deprecated since 1905
 * @description
 * The alertCollectionLegacySupport exposes an interface to the alertService to handle the
 * legacy removeAlertById function
 */
export class AlertCollectionLegacySupport {
    
    constructor(alertCollection: AlertCollection);
    /**
     * @ngdoc method
     * @deprecated since 1905
     * @name AlertServiceModule.service:AlertCollectionLegacySupport#removeAlertById
     * @methodOf AlertServiceModule.service:AlertCollectionLegacySupport
     * @param {string} id the id of the alert to be removed.
     */
    removeAlertById(id: string): void;
}



/**
 * @ngdoc service
 * @name AlertServiceModule.service:AlertCollectionServiceFacade
 * @description
 * The alertCollectionServiceFacade is the interface of alertCollection exposed to the service layer of the application
 */
export class AlertCollectionServiceFacade {
    
    constructor(alertCollection: AlertCollection);
    /**
     * @ngdoc method
     * @name AlertServiceModule.service:AlertCollectionServiceFacade#addAlert
     * @methodOf AlertServiceModule.service:AlertCollectionServiceFacade
     * @param {Alert} newAlert the new alert to be added to the collection.
     */
    addAlert(newAlert: Alert): void;
    /**
     * @ngdoc method
     * @name AlertServiceModule.service:AlertCollectionServiceFacade#removeAlert
     * @methodOf AlertServiceModule.service:AlertCollectionServiceFacade
     * @param {Alert} alertToRemove the alert to be removed from the collection.
     */
    removeAlert(alertToRemove: Alert): void;
}

/// <reference types="angular-mocks" />
/// <reference types="angular-sanitize" />





/**
 * @ngdoc service
 * @name AlertServiceModule.service:AlertFactory
 * @description
 * The alertFactory allows you to create an instances of type Alert.<br />
 * When possible, it is better to use {@link AlertServiceModule.service:AlertService AlertService} to show alerts.<br />
 * This factory is useful when one of the Alert class methods is needed, like
 * hide() or isDisplayed(), or if you want to create a single instance and hide/show when necessary.
 */
export class AlertFactory {
    
    
    
    
    
    
    
    constructor(promiseUtils: PromiseUtils, windowUtils: WindowUtils, $log: angular.ILogService, sanitize: angular.sanitize.ISanitizeService, alertCollectionServiceFacade: AlertCollectionServiceFacade, lodash: lo.LoDashStatic, SE_ALERT_DEFAULTS: TypedMap<string>);
    /**
     * @ngdoc method
     * @name AlertServiceModule.service:AlertFactory#createAlert
     * @methodOf AlertServiceModule.service:AlertFactory
     * @param {Object | string} alertConf The alert's configuration {@link smarteditServicesModule.interface: IAlertConfig IAlertConfig}
     * @returns {Alert} An {@link Alert Alert} instance
     */
    createAlert(alertConf: IAlertConfig | string): Alert;
    /**
     * @ngdoc method
     * @name AlertServiceModule.service:AlertFactory#createInfo
     * @methodOf AlertServiceModule.service:AlertFactory
     * @param {Object | string} alertConf The alert's configuration {@link smarteditServicesModule.interface: IAlertConfig IAlertConfig}
     * @returns {Alert} An {@link Alert Alert} instance with type set to INFO
     */
    createInfo(alertConf: IAlertConfig | string): Alert;
    /**
     * @ngdoc method
     * @name AlertServiceModule.service:AlertFactory#createDanger
     * @methodOf AlertServiceModule.service:AlertFactory
     * @param {Object | string} alertConf The alert's configuration {@link smarteditServicesModule.interface: IAlertConfig IAlertConfig}
     * @returns {Alert} An {@link Alert Alert} instance with type set to DANGER
     */
    createDanger(alertConf: IAlertConfig | string): Alert;
    /**
     * @ngdoc method
     * @name AlertServiceModule.service:AlertFactory#createWarning
     * @methodOf AlertServiceModule.service:AlertFactory
     * @param {Object | string} alertConf The alert's configuration {@link smarteditServicesModule.interface: IAlertConfig IAlertConfig}
     * @returns {Alert} An {@link Alert Alert} instance with type set to WARNING
     */
    createWarning(alertConf: IAlertConfig | string): Alert;
    /**
     * @ngdoc method
     * @name AlertServiceModule.service:AlertFactory#createSuccess
     * @methodOf AlertServiceModule.service:AlertFactory
     * @param {Object | string} alertConf The alert's configuration {@link smarteditServicesModule.interface: IAlertConfig IAlertConfig}
     * @returns {Alert} An {@link Alert Alert} instance with type set to SUCCESS
     */
    createSuccess(alertConf: IAlertConfig | string): Alert;
    /**
     * Allow the user to pass a str param or config object
     * Will convert a str param to { message: str }
     */
    
    /**
     * Create an Alert object
     */
    
}


/**
 * @ngdoc overview
 * @name AlertServiceModule
 */
export const SE_ALERT_DEFAULTS: SeValueProvider;
export class AlertServiceModule {
}



/// <reference types="angular-mocks" />



export interface IAnnouncement extends IAnnouncementConfig {
    timer?: angular.IPromise<void>;
    id: string;
}
export const ANNOUNCEMENT_DEFAULTS: {
    timeout: number;
    closeable: boolean;
};
export class AnnouncementService extends IAnnouncementService {
    
    
    
    
    
    
    
    constructor($q: angular.IQService, $log: angular.ILogService, lodash: lo.LoDashStatic, $timeout: angular.ITimeoutService, yjQuery: JQueryStatic, encode: (object: any) => string);
    showAnnouncement(announcementConfig: IAnnouncementConfig): angular.IPromise<string>;
    closeAnnouncement(announcementId: string): angular.IPromise<void>;
    /**
     * Method that returns all announcements.
     */
    _getAnnouncements(): IAnnouncement[];
    /**
     * Method used to close an announcement.
     */
    
    /**
     * Method that validates a given announcement data.
     * An announcement must contain only one of either message, template, or templateUrl property.
     */
    
}

/// <reference types="angular-resource" />





export class AuthenticationService extends IAuthenticationService {
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    constructor($q: angular.IQService, $injector: angular.auto.IInjectorService, $location: angular.ILocationService, languageService: LanguageService, modalService: any, LANDING_PAGE_PATH: string, DEFAULT_AUTHENTICATION_ENTRY_POINT: string, DEFAULT_AUTH_MAP: {}, DEFAULT_CREDENTIALS_MAP: ICredentialsMap, sharedDataService: ISharedDataService, storageService: IStorageService, crossFrameEventService: CrossFrameEventService, EVENTS: any, convertToArray: (objectToConver: any) => {
        key: string;
        value: any;
    }[], merge: <T, U>(source: T, target: U) => T & U, stringUtils: StringUtils, lodash: LoDashStatic);
    filterEntryPoints(resource: string): angular.IPromise<string[]>;
    isAuthEntryPoint(resource: string): angular.IPromise<boolean>;
    authenticate(resource: string): angular.IPromise<void>;
    logout(): angular.IPromise<any[]>;
    isReAuthInProgress(entryPoint: string): angular.IPromise<boolean>;
    setReAuthInProgress(entryPoint: string): angular.IPromise<void>;
    isAuthenticated(url: string): angular.IPromise<boolean>;
    
    
}

/// <reference types="angular-mocks" />





export class BootstrapService {
    
    
    
    
    
    
    
    
    
    constructor(lodash: lo.LoDashStatic, configurationExtractorService: ConfigurationExtractorService, sharedDataService: ISharedDataService, injectJS: any, $log: angular.ILogService, $http: angular.IHttpService, $q: angular.IQService, smarteditBootstrapGateway: any, moduleUtils: ModuleUtils);
    bootstrapContainerModules(configurations: ConfigurationObject): angular.IPromise<BootstrapPayload>;
    /**
     * Retrieve SmartEdit inner application configuration and dispatch 'bundle' event with list of resources.
     * @param configurations
     */
    bootstrapSEApp(configurations: ConfigurationObject): angular.IPromise<void>;
    
    
    /**
     * Applications are considered valid if they can be retrieved over the wire
     */
    
}







export * from './BootstrapService';
export * from './ConfigurationExtractorService';
export * from './SmarteditBundle';


export interface SmarteditBundleProperties {
    [index: string]: Cloneable;
    domain: string;
    smarteditroot: string;
    applications: string[];
}
export interface SmarteditBundleJsFile {
    src: string;
    namespaceToCheck?: string;
}
export interface SmarteditBundle {
    properties: SmarteditBundleProperties;
    js: SmarteditBundleJsFile[];
    css: string[];
}

/// <reference types="angular-mocks" />
/// <reference types="angular-route" />



export class CatalogAwareRouteResolverFunctions {
    /**
     * This function checks presence of a stored experience. It will redirect current user to the landing page
     * if the user doesn't have a read permission to the current catalog version. If the user has read permission for the
     * catalog version then EVENTS.EXPERIENCE_UPDATE is sent, but only when the experience has been changed.
     *
     * This function can be assigned to the resolve property of any route.
     */
    static storefrontResolve($q: angular.IQService, $log: angular.ILogService, $location: angular.ILocationService, experienceService: ExperienceService, sharedDataService: ISharedDataService, systemEventService: SystemEventService, EVENTS: any, LANDING_PAGE_PATH: string, catalogVersionPermissionService: any): angular.IPromise<any>;
    /**
     * This function initializes new experience based on route params. It will redirect current user to the landing page
     * if the user doesn't have a read permission to the current catalog version. If the user has read permission for the
     * catalog version then EVENTS.EXPERIENCE_UPDATE is sent, but only when the experience has been changed.
     *
     * This function can be assigned to the resolve property of any route.
     */
    static experienceFromPathResolve($route: angular.route.IRouteService, $q: angular.IQService, $log: angular.ILogService, $location: angular.ILocationService, experienceService: ExperienceService, sharedDataService: ISharedDataService, systemEventService: SystemEventService, EVENTS: any, LANDING_PAGE_PATH: string, catalogVersionPermissionService: any): angular.IPromise<any>;
    
}
export class CatalogAwareRouteResolverModule {
}



/// <reference types="angular" />

export interface CatalogVersionSyncPermission {
    canSynchronize: boolean;
    targetCatalogVersion: string;
}
export interface CatalogVersionPermissionMap {
    key: string;
    value: string;
}
export interface CatalogVersionPermission {
    catalogId: string;
    catalogVersion: string;
    permissions: CatalogVersionPermissionMap[];
    syncPermissions: CatalogVersionSyncPermission[];
}
/**
 * @ngdoc object
 * @name smarteditServicesModule.object:CATALOG_VERSION_PERMISSIONS_RESOURCE_URI
 *
 * @description
 * Path to fetch permissions of a given catalog version.
 */
export const CATALOG_VERSION_PERMISSIONS_RESOURCE_URI_CONSTANT = "/permissionswebservices/v1/permissions/principals/:principal/catalogs";
/**
 * @ngdoc service
 * @name smarteditServicesModule.service:catalogVersionPermissionRestService
 *
 * @description
 * The catalog version permission service is used to check if the current user has been granted certain permissions
 * on a given catalog ID and catalog Version.
 */
export class CatalogVersionPermissionRestService {
    
    
    
    
    constructor(restServiceFactory: IRestServiceFactory, sessionService: ISessionService, CATALOG_VERSION_PERMISSIONS_RESOURCE_URI: string, URIBuilder: {
        new (uri: string): IURIBuilder;
    });
    /**
     * @ngdoc method
     * @name smarteditServicesModule.service:catalogVersionPermissionRestService#getCatalogVersionPermissions
     * @methodOf smarteditServicesModule.service:catalogVersionPermissionRestService
     *
     * @description
     * This method returns permissions from the Catalog Version Permissions Service API.
     *
     * Sample Request:
     * GET /permissionswebservices/v1/permissions/principals/{principal}/catalogs?catalogId=apparel-deContentCatalog&catalogVersion=Online
     *
     * Sample Response from API:
     * {
     * "permissionsList": [
     *     {
     *       "catalogId": "apparel-deContentCatalog",
     *       "catalogVersion": "Online",
     *       "permissions": [
     *         {
     *           "key": "read",
     *           "value": "true"
     *         },
     *         {
     *           "key": "write",
     *           "value": "false"
     *         }
     *       ],
     *      "syncPermissions": [
     *        {
     *          "canSynchronize": "true",
     *          "targetCatalogVersion": "Online"
     *        }
     *     }
     *    ]
     * }
     *
     * Sample Response returned by the service:
     * {
     *   "catalogId": "apparel-deContentCatalog",
     *   "catalogVersion": "Online",
     *   "permissions": [
     *      {
     *        "key": "read",
     *        "value": "true"
     *      },
     *      {
     *        "key": "write",
     *        "value": "false"
     *      }
     *     ],
     *    "syncPermissions": [
     *      {
     *        "canSynchronize": "true",
     *        "targetCatalogVersion": "Online"
     *      }
     *    ]
     *  }
     *
     * @param {String} catalogId The Catalog ID
     * @param {String} catalogVersion The Catalog Version name
     *
     * @returns {IPromise} A Promise which returns an object exposing a permissions array containing the catalog version permissions
     */
    getCatalogVersionPermissions(catalogId: string, catalogVersion: string): angular.IPromise<CatalogVersionPermission | {}>;
    
}













export class TranslationsFetchService implements ITranslationsFetchService {
    
    constructor(httpClient: HttpClient);
    get(lang: string): Promise<TranslationMap>;
}





/// <reference types="angular" />
/// <reference types="angular-mocks" />



/**
 * @ngdoc service
 * @name smarteditServicesModule.service:IframeManagerService
 *
 * @description
 * The iFrame Manager service provides methods to load the storefront into an iframe. The preview of the storefront can be loaded for a specified input homepage and a specified preview ticket. The iframe src attribute is updated with that information in order to display the storefront in SmartEdit.
 */
export class IframeManagerService {
    
    
    
    
    
    
    
    
    
    
    
    
    
    constructor($q: angular.IQService, $log: angular.ILogService, $http: angular.IHttpService, DEVICE_SUPPORTS: DeviceSupport[], DEVICE_ORIENTATIONS: DeviceOrientation[], getOrigin: (url?: string) => string, getURI: (url: string) => string, parseQuery: (url: string) => TypedMap<string>, SMARTEDIT_IFRAME_ID: string, yjQuery: JQueryStatic, sharedDataService: ISharedDataService);
    /**
     * @ngdoc method
     * @name smarteditServicesModule.service:IframeManagerService#setCurrentLocation
     * @methodOf smarteditServicesModule.service:IframeManagerService
     *
     * @description
     * This method sets the current page location and stores it in the service. The storefront will be loaded with this location.
     *
     * @param {String} URL Location to be stored
     */
    setCurrentLocation(location: string): void;
    getIframe(): JQuery;
    getIFrameSrc(): string;
    isCrossOrigin(): boolean;
    /**
     * @ngdoc method
     * @name smarteditServicesModule.service:IframeManagerService#load
     * @methodOf smarteditServicesModule.service:IframeManagerService
     *
     * @description
     * This method loads the storefront within an iframe by setting the src attribute to the specified input URL.
     * If this method is called within the context of a new or updated experience, prior to the loading, it will check if the page exists.
     * If the pages does not exist (the server returns a 404 and a content-type:text/html), the user will be redirected to the homepage of the storefront. Otherwise,
     * the user will be redirected to the requested page for the experience.
     *
     * @param {String} URL The URL of the storefront.
     * @param {Boolean =} checkIfFailingHTML Boolean indicating if we need to check if the page call returns a 404
     * @param {String =} homepageInPreviewMode URL of the storefront homepage in preview mode if it's a new experience
     *
     */
    load(url: string, checkIfFailingHTML?: boolean, pageInPreviewMode?: string): void;
    /**
     * @ngdoc method
     * @name smarteditServicesModule.service:IframeManagerService#loadPreview
     * @methodOf smarteditServicesModule.service:IframeManagerService
     *
     * @description
     * This method loads the preview of the storefront for a specified input homepage URL or a page from the page list, and for a specified preview ticket.
     * This method will add '/cx-preview' as specified in configuration.storefrontPreviewRoute to the URI and append the preview ticket in the query string.
     * <br/>If it is an initial load,  {@link smarteditServicesModule.service:IframeManagerService#load load} will be called with this modified homepage or page from page list.
     * <br/>If it is a subsequent call, the modified homepage will be called through Ajax to initialize the preview (storefront constraint) and then
     * {@link smarteditServicesModule.service:IframeManagerService#load load} will be called with the current location.
     *
     * @param {String} homePageOrPageFromPageList The URL of the storefront homepage or a page from the page list for a given experience context.
     * @param {String} previewTicket The preview ticket.
     */
    loadPreview(homePageOrPageFromPageList: string, previewTicket: string): void;
    /**
     * @ngdoc method
     * @name smarteditServicesModule.service:IframeManagerService#initializeCatalogPreview
     * @methodOf smarteditServicesModule.service:IframeManagerService
     * @deprecated since 1808, use {@link smarteditServicesModule.service:ExperienceService#initializeExperience initializeExperience}
     *
     * @description
     * Deprecated since 1808, use {@link smarteditServicesModule.service:ExperienceService#initializeExperience initializeExperience}
     */
    initializeCatalogPreview(): Error;
    apply(deviceSupport?: DeviceSupport, deviceOrientation?: DeviceOrientation): void;
    applyDefault(): void;
    
    
    
}

export * from 'smarteditcontainer/services/bootstrap';
export * from 'smarteditcontainer/services/announcement/AnnouncementServiceOuter';
export * from 'smarteditcontainer/services/notifications';
export * from 'smarteditcontainer/services/DelegateRestServiceOuter';
export * from 'smarteditcontainer/services/DragAndDropCrossOriginOuter';
export * from 'smarteditcontainer/services/ExperienceServiceOuter';



export * from 'smarteditcontainer/services/perspectives/FeatureServiceOuter';
export * from 'smarteditcontainer/services/PageInfoServiceOuter';
export * from 'smarteditcontainer/services/PreviewServiceOuter';
export * from 'smarteditcontainer/services/ProductService';
export * from 'smarteditcontainer/services/perspectives/PerspectiveServiceOuter';
export * from 'smarteditcontainer/services/RestServiceFactory';
export * from 'smarteditcontainer/services/SessionServiceOuter';
export * from 'smarteditcontainer/services/SharedDataServiceOuter';
export * from 'smarteditcontainer/services/SiteService';
export * from 'smarteditcontainer/services/StorageServiceOuter';

export * from 'smarteditcontainer/services/CatalogServiceOuter';
export * from 'smarteditcontainer/services/UrlServiceOuter';
export * from 'smarteditcontainer/services/WaitDialogServiceOuter';
export * from 'smarteditcontainer/services/catalogAwareRouteResolverModule';
export * from 'smarteditcontainer/services/storage';
export * from 'smarteditcontainer/services/PermissionServiceOuter';
export * from 'smarteditcontainer/services/CatalogVersionPermissionRestService';
export * from 'smarteditcontainer/services/HeartBeatService';
export * from 'smarteditcontainer/services/ConfigurationService';
export * from 'smarteditcontainer/services/LoginModalService';
export * from 'smarteditcontainer/services/SmarteditServicesModule';



export interface LoginDialogForm {
    posted: boolean;
    errorMessage: string;
    failed: boolean;
    $valid: boolean;
}
export interface LoginData {
    initialized?: boolean;
    authURI: string;
    clientCredentials: ICredentialsMapRecord;
}
export interface LoginModalFeedback {
    userHasChanged: boolean;
}
export interface LoginModalService {
    initialized: boolean;
    authURI: string;
    auth: {
        username: string;
        password: string;
    };
    submit(loginDialogForm: LoginDialogForm): angular.IPromise<LoginModalFeedback>;
}

export * from './NotificationServiceOuter';
export * from './NotificationMouseLeaveDetectionServiceOuter';







/// <reference types="angular-mocks" />


/**
 * @ngdoc object
 * @name smarteditServicesModule.object:DEFAULT_RULE_NAME
 * @description
 * The name used to register the default rule.
 */
export const DEFAULT_DEFAULT_RULE_NAME = "se.permission.service.default.rule";
export type RulePermissionNames = TypedMap<PermissionContext[]>;
export class PermissionService extends IPermissionService {
    
    
    
    
    
    
    
    static resetForTests(): void;
    
    
    
    
    
    constructor($q: angular.IQService, $log: angular.ILogService, DEFAULT_RULE_NAME: string, EVENTS: TypedMap<string>, EVENT_PERSPECTIVE_CHANGED: string, systemEventService: SystemEventService, crossFrameEventService: CrossFrameEventService);
    getPermission(permissionName: string): Permission;
    unregisterDefaultRule(): void;
    registerPermission(permission: Permission): void;
    hasCachedResult(ruleName: string, key: string): boolean;
    clearCache(): void;
    isPermitted(permissions: MultiNamePermissionContext[]): angular.IPromise<boolean>;
    /**
     * This method adds a promise obtained by calling the pre-configured rule.verify function to the rulePromises
     * map if the result does not exist in the rule's cache. Otherwise, a promise that contains the cached result
     * is added.
     *
     * The promise obtained from the rule.verify function is chained to allow short-circuiting the permission
     * verification process. If a rule resolves with a false result or with an error, the chained promise is
     * rejected to stop the verification process without waiting for all other rules to resolve.
     *
     * @param {Object} rulePromises An object that maps rule names to promises.
     * @param {Object} rulePermissionNames An object that maps rule names to permission name arrays.
     * @param {String} ruleName The name of the rule to verify.
     */
    
    /**
     * This method validates a permission name. Permission names need to be prefixed by at least one
     * namespace followed by a "." character to be valid.
     *
     * Example: se.mynamespace is valid.
     * Example: mynamespace is not valid.
     */
    
    /**
     * This method returns an object that maps rule names to promises.
     */
    
    /**
     * This method returns true if a default rule is already registered.
     *
     * @returns {boolean} true if the default rule has been registered, false otherwise.
     */
    
    /**
     * This method returns the rule's cached result for the given key.
     *
     * @param {Object} ruleName The name of the rule for which to lookup the cached result.
     * @param {String} key The cached key to lookup..
     *
     * @returns {Boolean} The cached result, if it exists, null otherwise.
     */
    
    /**
     * This method generates a key to store a rule's result for a given combination of
     * permissions in its cache. It is done by sorting the list of permissions by name
     * and serializing it.
     *
     * @param {Object[]} permissions A list of permissions with a name and context.
     *
     * [{
     *     name: "permission.name"
     *     context: {
     *         key: "value"
     *     }
     * }]
     *
     * @returns {String} The serialized sorted list of permissions.
     */
    
    /**
     * This method goes through the permission name arrays associated to rule names to remove any duplicate
     * permission names.
     *
     * If one or more permission names with the same context are found in a rule name's permission name array,
     * only one entry is kept.
     */
    
    /**
     * This method returns an object mapping rule name to permission name arrays.
     *
     * It will iterate through the given permission name object array to extract the permission names and contexts,
     * populate the map and clean it up by removing duplicate permission name and context pairs.
     */
    
    /**
     * This method will populate rulePermissionNames with the rules associated to the permission with the given
     * permissionName.
     *
     * If no permission is registered with the given permissionName and a default rule is registered, the default
     * rule is added to rulePermissionNames.
     *
     * If no permission is registered with the given permissionName and no default rule is registered, an error
     * is thrown.
     */
    
    /**
     * This method will add an object with the permissionName and permissionContext to rulePermissionNames.
     *
     * Since rules can have multiple names, the map will use the first name in the rule's name list as its key.
     * This way, each rule will be called only once for every permission name and context.
     *
     * If the rule associated to a given rule name is already in rulePermissionNames, the permission will be
     * appended to the associated array. Otherwise, the rule name is added to the map and its permission name array
     * is created.
     */
    
    /**
     * This method returns the rule registered with the given name.
     *
     * @param {String} ruleName The name of the rule to lookup.
     *
     * @returns {Object} rule The rule with the given name, undefined otherwise.
     */
    
    
    
    
    
    
    
    
    
    
}









/// <reference types="angular" />

/**
 * @ngdoc interface
 * @name smarteditServicesModule.interface:IProductSearch
 * @description
 * Interface used by {@link smarteditServicesModule.service:ProductService ProductService} for product search
 */
export interface IProductSearch {
    /**
     * @ngdoc property
     * @name catalogId
     * @propertyOf smarteditServicesModule.interface:IProductSearch
     * @description id of the catalog
     */
    catalogId: string;
    /**
     * @ngdoc property
     * @name catalogVersion
     * @propertyOf smarteditServicesModule.interface:IProductSearch
     * @description version of the catalog
     */
    catalogVersion: string;
}
/**
 * @ngdoc service
 * @name smarteditServicesModule.service:ProductService
 * @description
 * The ProductService provides is used to access products from the product catalog
 */
export class ProductService {
    
    
    
    constructor(restServiceFactory: IRestServiceFactory, PRODUCT_RESOURCE_API: string, PRODUCT_LIST_RESOURCE_API: string);
    /**
     * @ngdoc method
     * @name smarteditServicesModule.service:ProductService#getProductById
     * @methodOf smarteditServicesModule.service:ProductService
     * @description
     * Returns a Product that matches the given siteUID and productUID
     * @param {String} siteUID unique site ID
     * @param {String} productUID unique product ID
     * @returns {Object} A {@link https://docs.angularjs.org/api/ng/service/$q promise} of IProduct
     */
    getProductById(siteUID: string, productUID: string): angular.IPromise<IProduct>;
    /**
     * @ngdoc method
     * @name smarteditServicesModule.service:ProductService#findProducts
     * @methodOf smarteditServicesModule.service:ProductService
     * @description
     * Returns a list of Products from the catalog that match the given mask
     * @param {Object} productSearch {@link smarteditServicesModule.interface:IProductSearch productSearch} catalog search criteria
     * @param {Object} pageable  object
     * @returns {Object} A {@link https://docs.angularjs.org/api/ng/service/$q promise} of Page<IProduct>
     *
     */
    findProducts(productSearch: IProductSearch, pageable: Pageable): angular.IPromise<Page<IProduct>> | Error;
    
}







/// <reference types="angular" />

/**
 * @ngdoc service
 * @name smarteditServicesModule.service:SiteService
 *
 * @description
 * The Site Service fetches all sites configured on the hybris platform using REST calls to the cmswebservices sites API.
 */
export class SiteService {
    
    
    
    
    constructor(restServiceFactory: IRestServiceFactory, SITES_RESOURCE_URI: string);
    /**
     * @ngdoc method
     * @name smarteditServicesModule.service:SiteService#getAccessibleSites
     * @methodOf smarteditServicesModule.service:SiteService
     *
     * @description
     * Fetches a list of sites for which user has at-least read access to one of the non-active catalog versions.
     *
     * @returns {Object} A {@link https://docs.angularjs.org/api/ng/service/$q promise} of {@link smarteditServicesModule.interface:ISite ISite} array.
     */
    getAccessibleSites(): angular.IPromise<ISite[]>;
    /**
     * @ngdoc method
     * @name smarteditServicesModule.service:SiteService#getSites
     * @methodOf smarteditServicesModule.service:SiteService
     *
     * @description
     * Fetches a list of sites configured for accessible sites. The list of sites fetched using REST calls through
     * the cmswebservices sites API.
     *
     * @returns {Object} A {@link https://docs.angularjs.org/api/ng/service/$q promise} of {@link smarteditServicesModule.interface:ISite ISite} array.
     */
    getSites(): angular.IPromise<ISite[]>;
    /**
     * @ngdoc method
     * @name smarteditServicesModule.service:SiteService#getSiteById
     * @methodOf smarteditServicesModule.service:SiteService
     *
     * @description
     * Fetches a site, configured on the hybris platform, by its uid. The sites fetched using REST calls through
     * cmswebservices sites API.
     * @param {String} uid unique site ID
     * @returns {object} A {@link https://docs.angularjs.org/api/ng/service/$q promise} of {@link smarteditServicesModule.interface:ISite ISite}.
     */
    getSiteById(uid: string): angular.IPromise<ISite>;
}

/**
 * @ngdoc overview
 * @name smarteditServicesModule
 *
 * @description
 * Module containing all the services shared within the smartedit container application
 */
export class SmarteditServicesModule {
}





















export * from "./controller/memorystorage/MemoryStorageController";
export * from "./controller/memorystorage/MemoryStorage";
export * from "./controller/webstorage/AbstractWebStorageController";
export * from "./controller/webstorage/LocalStorageController";
export * from "./controller/webstorage/SessionStorageController";
export * from "./controller/webstorage/WebStorage";
export * from "./controller/webstorage/WebStorageBridge";
export * from "./gateway/StorageManagerGatewayOuter";
export * from "./gateway/StorageGatewayOuter";
export * from "./manager/StorageManager";
export * from "./metadata/MetaDataMapStorage";
export * from "./metadata/IStorageMetaData";
export * from "./defaultStorageProperties";
export * from "./StorageModuleOuter";
export * from "./StoragePropertiesService";








/**
 * Storage API
 * @type {angular.IModule}
 */
export class StorageModule {
    static configure(properties?: TypedMap<any>): SeModuleWithProviders;
}




export interface ISessionAuth {
    [index: string]: IAuthToken | any;
}





/**
 * @ngdoc object
 * @name CatalogDetailsModule.object:CATALOG_DETAILS_COLUMNS
 *
 * @description
 * Injectable angular constant<br/>
 * This object provides an enumeration with values for each of the possible places to add items to
 * extend the {@link CatalogDetailsModule.component:catalogVersionDetails} component. Currently,
 * the available options are CATALOG_DETAILS_COLUMNS.LEFT and CATALOG_DETAILS_COLUMNS.RIGHT.
 *
 */
export const CATALOG_DETAILS_COLUMNS: {
    LEFT: string;
    RIGHT: string;
};
export class CatalogDetailsModule {
}


export interface CatalogDetailsItem {
    include: string;
}
/**
 * @ngdoc service
 * @name CatalogDetailsModule.service:catalogDetailsService
 * @description
 *
 * The catalog details Service makes it possible to add items in form of directive
 * to the catalog details directive
 *
 */
export class CatalogDetailsService {
    
    
    constructor(CATALOG_DETAILS_COLUMNS: TypedMap<string>);
    /**
     * @ngdoc method
     * @name CatalogDetailsModule.service:catalogDetailsService#addItems
     * @methodOf CatalogDetailsModule.service:catalogDetailsService
     *
     * @description
     * This method allows to add a new item/items to the template array.
     *
     * @param {Array} items An array that hold a list of items.
     * @param {String=} column The place where the template will be added to. If this value is empty
     * the template will be added to the left side by default. The available places are defined in the
     * constant {@link CatalogDetailsModule.object:CATALOG_DETAILS_COLUMNS}
     */
    addItems(items: CatalogDetailsItem[], column: string): void;
    /**
     * @ngdoc method
     * @name CatalogDetailsModule.service:catalogDetailsService#getItems
     * @methodOf CatalogDetailsModule.service:catalogDetailsService
     *
     * @description
     * This retrieves the list of items currently extending catalog version details components.
     */
    getItems(): {
        left: CatalogDetailsItem[];
        right: CatalogDetailsItem[];
    };
}


/**
 * @ngdoc directive
 * @name CatalogDetailsModule.component:catalogDetails
 * @scope
 * @restrict E
 * @element catalog-details
 *
 * @description
 * Component responsible for displaying a catalog details. It contains a thumbnail representing the whole
 * catalog and the list of catalog versions available to the current user.
 *
 * This component is currently used in the landing page.
 *
 * @param {< String} catalog The catalog that needs to be displayed
 * @param {< Boolean} isCatalogForCurrentSite A flag that specifies if the provided catalog is associated with the selected site in the landing page
 */
export class CatalogDetailsComponent {
    
    catalog: ICatalog;
    isCatalogForCurrentSite: boolean;
    activeCatalogVersion: ICatalogVersion;
    siteIdForCatalog: string;
    sortedCatalogVersions: ICatalogVersion[];
    collapsibleConfiguration: {
        expandedByDefault: boolean;
    };
    cataloDeviderImage: 'static-resources/images/icon_catalog_arrow.png';
    constructor(catalogService: ICatalogService);
    $onInit(): void;
    
}



/**
 * @ngdoc overview
 * @name CatalogDetailsModule
 * @description
 * This module contains the {@link CatalogDetailsModule.component:catalogVersionDetails} component.
 */
/**
 * @ngdoc directive
 * @name CatalogDetailsModule.component:catalogVersionDetails
 * @scope
 * @restrict E
 * @element catalog-version-details
 *
 * @description
 * Component responsible for displaying a catalog version details. Contains a link, called homepage, that
 * redirects to the default page with the right experience (site, catalog, and catalog version).
 *
 * Can be extended with custom items to provide new links and functionality.
 *
 * @param {<Object} catalog Object representing the parent catalog of the catalog version to display.
 * @param {<Object} catalogVersion Object representing the catalog version to display.
 * @param {<Object} activeCatalogVersion Object representing the active catalog version of the parent catalog.
 * @param {<String} siteId The site associated with the provided catalog.
 */
export class CatalogVersionDetailsComponent implements ISeComponent {
    
    catalog: ICatalog;
    catalogVersion: ICatalogVersion;
    activeCatalogVersion: ICatalogVersion;
    siteId: string;
    leftItems: CatalogDetailsItem[];
    rightItems: CatalogDetailsItem[];
    constructor(catalogDetailsService: CatalogDetailsService);
    $onInit(): void;
}


/**
 * @ngdoc directive
 * @name CatalogDetailsModule.component:catalogVersionsThumbnailCarousel
 * @scope
 * @restrict E
 * @element catalog-versions-thumbnail-carousel
 *
 * @description
 * Component responsible for displaying a thumbnail of the provided catalog. When clicked,
 * it redirects to the storefront page for the catalog's active catalog version.
 *
 * @param {< Object} catalog Object representing the current catalog.
 * @param {< String} siteId The ID of the site associated with the provided catalog.
 */
export class CatalogVersionsThumbnailCarouselComponent {
    
    catalog: ICatalog;
    siteId: string;
    selectedVersion: ICatalogVersion;
    constructor(experienceService: IExperienceService);
    $onInit(): void;
    onClick(): void;
    
}


/**
 * @ngdoc directive
 * @name CatalogDetailsModule.directive:homePageLink
 * @scope
 * @restrict E
 * @element <home-page-link></home-page-link>
 *
 * @description
 * Directive that displays a link to the main storefront page.
 *
 * @param {< Object} catalog Object representing the provided catalog.
 * @param {< Boolean} catalogVersion Object representing the provided catalog version.
 * @param {< String} siteId The ID of the site the provided catalog is associated with.
 */
export class HomePageLinkComponent {
    
    catalog: ICatalog;
    catalogVersion: ICatalogVersion;
    siteId: string;
    constructor(experienceService: IExperienceService);
    onClick(): void;
}


export const SmarteditContainerFactory: (bootstrapPayload: BootstrapPayload) => any;

}